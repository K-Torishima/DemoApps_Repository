# 型の設計指針

Swiftは構造体、列挙型、プロトコルの表現力が豊かであることがあげられる、
その表現力の向上で型を設計する際の選択肢が広がった
オプショナル、let var によって、型のプロパティの特性も細かくコントロールできる

## クラスに対する構造体の優位性
swiftではクラスで実現可能なことの大半は構造体でも再現できる
したがって、型を設計するたびに、クラスにすべきか構造体にすべきかを検証することとなる
ただ実際には、swiftの標準ライブラリの型のほとんどが構造体として宣言されていることから明らかかなとおり、
swiftでは構造体を積極的に利用した設計が推奨される
できるだけ構造体を利用することを検討し、その上で要求を満たせない場合に初めてクラスでの実装を検証すべき

### 参照型のクラスがもたらすバグ
なぜSiwftでは構造体が重視されているのか、
まず、classとの比較をする

- 例 気温を表すTemperature型と国を表すCountry型を定義し、国とその気温を表現する

``` swift

class Temperature {
    var celsius: Double = 0.
}

class Country {
    var temperature: Temperature

    init(temperature: Temperature) {
        self.temperature = temperature
    }
}

let temperature = Temperature();
temprature.celsius = 25
let Japan = Country(temperature: temperature)
temperature.celsius = 40

let Egypt = Country(temperature: temperature)
Japan.temperature.celsius // 40
Egypt.temperature.celsius // 40

```

このコードは日本の気温25度に、エジプトの気温を40度に設定する意図があるように見えますが、期待する結界になっていない。
どちらも40度になってしまっている
これはクラスが参照型であることに起因がある


参照型では、インスタンスが引数として渡された時、そのインスタンスの参照が渡される、
つまり上記の例では、同時Temprature型のインスタンスが二つのCountry型のインスタンスから参照されることになる
、そのため、tempratureプロパティの値を変更すると、それを参照している両方のインスタンスに影響してしまう

とは言え、上記のようなものは初歩的である
しかし複雑になると気付きにくい

- 例2 
  - 非同期処理が含まれている
  - dispatchQueue.async(_:)の引数として与えられるクロージャは非同期に実行される
  - 非同期処理は実行中の他の処理を止めない処理
  - そのためクロージャの実行と後続のコードの実行は保証されない

``` swift
import Dispatch

class Temprature {
    var celsius: Double = 0
}

let temprature = Temprature()
temprature.celsius = 25

// 別スレットでtempertureの値を編集

let dispatchQueue = DispatchQueue.global(pos: default)

dispatchQueue.async {
    temperature.celsius += 1
}

temperature.celsius += 1
temperature.celsius // 非同期処理の実行タイミングによって結果が異なる

```

このようなケースでは処理の実行によって結果が変わってしまう可能性がある
クラスの様々な箇所で共有され、それぞれの箇所で値が更新される
つまり、そのインスタンスがどのような経路を辿ってきたかによって実行結果が変わってしまい、コードの一部を見るだけで結果を推論することは困難になってしまう
このようなクラス特性は爆の温床になりがちである


