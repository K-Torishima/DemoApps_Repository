# Modules

Modulesとは、複数のソースコードを含む配布可能なプログラムの単位で、他のプログラムへのインポートが可能
SwiftでのModulesは、プログラムの名前空間を区切る単位にもなっている

## 再利用可能かつ配布可能なプログラム

- 特定のプログラムからの独立性の高いプログラムは、他のプロジェクトでも再利用可能
- モジュールには、汎用的なプログラムをうまく再利用するための仕組みが備わっている
- 名前空間を定義することで、モジュール間の名前の衝突を解消したり、公開するインターフェースを握ることでモジュール外からの想定外の利用を防いだりできる
- 複数のプロジェクトで利用されることを想定したプログラムを書く場合は、モジュール化を前提にすると良い

## モジュールの再利用

- モジュールを作成するにはSwiftPMでビルドターゲットを定義する
- ビルドターゲットはパッケージのビルド単位で、パッケージ内に複数定義できる
- 一つのビルドターゲットにたいし、一つのモジュールが定義される

### ビルドターゲットの定義

ビルドターゲットを作成する前に、ビルドターゲットを含めるパッケージを作成する

``` shell
mkdir Example
cd Example
touch Package.swift
```

ビルドターゲットはPackage.swiftで定義する
ここではLibraryという名前で定義する

``` shell
// swift-tools-version: 5.1

import PackageDescription

let Packege(
    name: "Example",
    targets: [
        .target(name: Library)
    ]
)
```

- パッケージやビルドターゲットには、大文字始まりの名前をつけるのが一般的
- ビルドターゲットがエントリポイントのmain.swiftを含む場合は、ビルドターゲットの名前が実行ファイルの名前になるため、小文字始まりの名前をつけることもある
  
  定義したターゲット名と同名のディレクトリをSources以下に作成

``` shell
mkdir -p Sources/Library
```

- ビルドターゲットに含めるソースコードは、上記のディレクトリに配置する
- 配置されたソースコードはビルドターゲットに含まれ、モジュールとして、外部のプログラムから再利用が可能となる
- エントリポイントのmain.swiftが含まれる場合は外部のプログラムから利用できなくなるため注意が必要
  
### ビルドターゲットの依存関係の定義
- あるモジュールから他のモジュールを利用するには、マニフェストファイルPackage.swiftに依存関係を記述する

``` shell
import PackageDescription

let Packege = Package(
    name:"Example",
    targets: [
        .target(name: Library),
        .target(name:"AnotherLibrary", dependencies:["Library"]),
    ]
)
```

このように依存関係を定義しておくと、ビルドターゲットAnotherLibraryをビルドする前にビルドターゲットLibraryがビルドされ、モジュールLibraryが利用可能な状態になる

### 外部パッケージの利用

- SwiftPMはパッケージ内のモジュールだけでなく、外部パッケージのモジュールも利用できる
- 外部パッケージの利用の設定は、マニフェストファイルPackage.swiftで行う
- Package型のイニシャライザの引数dependenciesに、利用するパッケージのURLとバージョンのセットを列挙する

``` shell
import PackageDescription

let package = Package(
    name: "Example",
    dependencis: [
        .package(url: "https://github.com/ReactiveX/RxSwift.git", .upToNextMajor(form: "5.0.0")),
    ],
    targets: [
        .target(name:"Library",
        dependencies:["RxSwift"]),
    ]
)

```

- パッケージが依存する外部パッケージに含まれるモジュールは、パッケージ内で定義されたモジュールと同様に扱える
- ビルドターゲットLibraryの依存にビルドターゲットRxSwiftを指定し、Libraryモジュールから、RxSwiftモジュールを利用可能にしている


## 名前空間 名前が一意となる範囲

- 名前空間とは、型名や変数名や定数名や関数名などの名前が一意となる範囲で、名前の衝突を避けつつも名前を適切な短さに保つことに役立つ
- モジュールは名前空間を区切る単位となっており、一つのモジュールを定義すると一つの名前空間が定義される
- 同じモジュール内のグローバルスコープでは、同一の名前を持つ型、変数、定数、関数を複数存在させることはできないが、別モジュールであれば可能
- 例えば、HTTP通信を行うモジュールと永続ストアにアクセスするモジュールの両方にRequestという型が存在したとしても、両方の型は同時に使用できる
  
### import文　-- モジュールのインポートを行う文

同一モジュール内であれば、そのアクセスレベルが、privateやfilePrivateでない限り、別ファイルの要素であっても自由にアクセスできる
別のモジュールにある要素にアクセスするには、import文を使用して自前にそのモジュールをインポートする必要がある

```swift
import modelsName
```

- importを行うと、importしたファイル内では, importされたモジュールが公開している方や、変数をモジュール内の型や変数、定数と同様に扱える
  
``` swift
import modelsName
// ここでは、モジュールで公開されている要素に何も指定することなくアクセス可能
```
- import文によるインポートの有効範囲は、ファイル単位である
- 別ファイルで同じモジュールを使用する場合は、そのファイルでもいインポートが必要


### 名前の衝突の回避
- モジュールは名前空間の単位でもあるため、モジュール間で使用する名前が重複しても問題ない
- ただし、インポートした複数のモジュール間で重複した名前を使用する時は、曖昧さを回避するために名前の先頭にモジュール名を加えて明示する必要がある
- どのモジュールを指しているのか曖昧なものは、コンパイルerrorになる
- モジュール名を明示するには、モジュール名.アクセスしたい要素を指定する
- 